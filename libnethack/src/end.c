/* vim:set cin ft=c sw=4 sts=4 ts=8 et ai cino=Ls\:0t0(0 : -*- mode:c;fill-column:80;tab-width:8;c-basic-offset:4;indent-tabs-mode:nil;c-file-style:"k&r" -*-*/
/* Copyright (c) Stichting Mathematisch Centrum, Amsterdam, 1985. */
/* NetHack may be freely redistributed.  See license for details. */

#include <math.h>
#include "hack.h"
#include "eshk.h"
#include "dlb.h"

        /* these probably ought to be generated by makedefs, like LAST_GEM */
#define FIRST_GEM    DILITHIUM_CRYSTAL
#define FIRST_AMULET AMULET_OF_ESP
#define LAST_AMULET  AMULET_OF_YENDOR

struct valuable_data {
    long count;
    int typ;
};

static struct valuable_data
              gems[LAST_GEM + 1 - FIRST_GEM + 1],       /* 1 extra for glass */
              amulets[LAST_AMULET + 1 - FIRST_AMULET];

static const struct val_list {
    struct valuable_data *list;
    int size;
} valuables[] = {
    {
    gems, sizeof gems / sizeof *gems}
    , {
    amulets, sizeof amulets / sizeof *amulets}
    , {
    0, 0}
};

static void disclose(int, boolean, long);
static void dump_disclose(int);
static void get_valuables(struct obj *);
static void sort_valuables(struct valuable_data *, int);
static int artifact_score(struct obj *, boolean, struct menulist *);
static void savelife(int);
static boolean check_survival(int how, char *kilbuf);
static boolean should_query_disclose_options(char *defquery);
static void container_contents(struct obj *, boolean, boolean);
static void NORETURN done_noreturn(int how);

#define done_stopprint program_state.stopprint

/*
 * The order of these needs to match the macros in hack.h.
 */
static const char *const deaths[] = {   /* the array of death */
    "died", "choked", "poisoned", "starvation", "drowning",
    "burning", "dissolving under the heat and pressure",
    "crushed", "turned to stone", "turned into slime",
    "genocided", "panic", "trickery",
    "quit", "escaped", "ascended"
};

static const char *const ends[] = {     /* "when you..." */
    "died", "choked", "were poisoned", "starved", "drowned",
    "burned", "dissolved in the lava",
    "were crushed", "turned to stone", "turned into slime",
    "were genocided", "panicked", "were tricked",
    "quit", "escaped", "ascended"
};

static char killbuf[BUFSZ];

extern const char *const killed_by_prefix[];    /* from topten.c */


/* "#quit" command or keyboard interrupt */
int
done2(void)
{
    if (yn("Really abandon this game and delete its save file?") == 'n') {
        flush_screen();
        if (multi > 0)
            nomul(0, NULL);
        if (multi == 0) {
            u.uinvulnerable = FALSE;    /* avoid ctrl-C bug -dlc */
            u.usleep = 0;
        }
        return 0;
    }

    done(QUIT);
    return 0;
}


void
done_in_by(struct monst *mtmp)
{
    char buf[BUFSZ];
    boolean distorted = (boolean) (Hallucination && canspotmon(mtmp));

    pline("You die...");
    buf[0] = '\0';
    killer_format = KILLED_BY_AN;
    /* "killed by the high priest of Crom" is okay, "killed by the high priest" 
       alone isn't */
    if ((mtmp->data->geno & G_UNIQ) != 0 &&
        !(mtmp->data == &mons[PM_HIGH_PRIEST] && !mtmp->ispriest)) {
        if (!type_is_pname(mtmp->data))
            strcat(buf, "the ");
        killer_format = KILLED_BY;
    }
    /* _the_ <invisible> <distorted> ghost of Dudley */
    if (mtmp->data == &mons[PM_GHOST] && mtmp->mnamelth) {
        strcat(buf, "the ");
        killer_format = KILLED_BY;
    }
    if (mtmp->minvis)
        strcat(buf, "invisible ");
    if (distorted)
        strcat(buf, "hallucinogen-distorted ");

    if (mtmp->data == &mons[PM_GHOST]) {
        strcat(buf, "ghost");
        if (mtmp->mnamelth)
            sprintf(eos(buf), " of %s", NAME(mtmp));
    } else if (mtmp->isshk) {
        sprintf(eos(buf), "%s %s, the shopkeeper",
                (mtmp->female ? "Ms." : "Mr."), shkname(mtmp));
        killer_format = KILLED_BY;
    } else if (mtmp->ispriest || mtmp->isminion) {
        /* m_monnam() suppresses "the" prefix plus "invisible", and it
           overrides the effect of Hallucination on priestname() */
        killer = m_monnam(mtmp);
        strcat(buf, killer);
    } else {
        strcat(buf, mtmp->data->mname);
        if (mtmp->mnamelth)
            sprintf(eos(buf), " called %s", NAME(mtmp));
    }

    if (multi) {
        if (*multi_txt)
            sprintf(eos(buf), ", while %s", multi_txt);
        else
            strcat(buf, ", while helpless");
    }
    killer = buf;
    if (mtmp->data->mlet == S_WRAITH)
        u.ugrave_arise = PM_WRAITH;
    else if (mtmp->data->mlet == S_MUMMY && urace.mummynum != NON_PM)
        u.ugrave_arise = urace.mummynum;
    else if (mtmp->data->mlet == S_VAMPIRE && Race_if(PM_HUMAN))
        u.ugrave_arise = PM_VAMPIRE;
    else if (mtmp->data == &mons[PM_GHOUL])
        u.ugrave_arise = PM_GHOUL;
    if (u.ugrave_arise >= LOW_PM && (mvitals[u.ugrave_arise].mvflags & G_GENOD))
        u.ugrave_arise = NON_PM;
    if (touch_petrifies(mtmp->data))
        done(STONING);
    else
        done(DIED);
    return;
}


/*VARARGS1*/
void
panic(const char *str, ...)
{
    char buf[BUFSZ];
    va_list the_args;

    va_start(the_args, str);

    if (program_state.panicking++)
        terminate();    /* avoid loops - this should never happen */

    raw_print(program_state.
              gameover ? "Postgame wrapup disrupted.\n" : !program_state.
              something_worth_saving ? "Program initialization has failed.\n" :
              "Suddenly, the dungeon collapses.\n");
    if (!wizard)
        raw_printf("Report error to \"%s\"%s.\n", WIZARD,
                   !program_state.
                   something_worth_saving ? "" :
                   " and it may be possible to rebuild.");
    if (program_state.something_worth_saving)
        dosave0(TRUE);

    vsprintf(buf, str, the_args);
    raw_print(buf);
    paniclog("panic", buf);

    va_end(the_args);
    done_noreturn(PANICKED);
}

static boolean
should_query_disclose_options(char *defquery)
{
    if (!defquery) {
        impossible("should_query_disclose_option: null defquery");
        return TRUE;
    }

    switch (flags.end_disclose) {
    default:   /* fall through */
    case DISCLOSE_PROMPT_DEFAULT_YES:
        *defquery = 'y';
        return TRUE;
    case DISCLOSE_YES_WITHOUT_PROMPT:
        *defquery = 'y';
        return FALSE;
    case DISCLOSE_PROMPT_DEFAULT_NO:
        *defquery = 'n';
        return TRUE;
    case DISCLOSE_NO_WITHOUT_PROMPT:
        *defquery = 'n';
        return FALSE;
    }
}


static void
disclose(int how, boolean taken, long umoney)
{
    char c = 0, defquery;
    char qbuf[QBUFSZ];
    boolean ask = should_query_disclose_options(&defquery);

    if (invent) {
        if (taken)
            sprintf(qbuf, "Do you want to see what you had when you %s?",
                    (how == QUIT) ? "quit" : "died");
        else
            strcpy(qbuf, "Do you want your possessions identified?");

        if (!done_stopprint) {
            c = ask ? yn_function(qbuf, ynqchars, defquery) : defquery;
            if (c == 'y') {
                struct obj *obj;

                for (obj = invent; obj; obj = obj->nobj) {
                    discover_object(obj->otyp, TRUE, FALSE, TRUE);
                    obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
                }
                display_inventory(NULL, TRUE);
                container_contents(invent, TRUE, TRUE);
            }
            if (c == 'q')
                done_stopprint++;
        }
    }

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see your attributes?", ynqchars,
                              defquery) : defquery;
        if (c == 'y')
            enlightenment(how >= PANICKED ? 1 : 2);     /* final */
        if (c == 'q')
            done_stopprint++;
    }

    if (!done_stopprint)
        list_vanquished(defquery, ask);

    if (!done_stopprint)
        list_genocided(defquery, ask);

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see your conduct?", ynqchars,
                              defquery) : defquery;
        if (c == 'y')
            show_conduct(how >= PANICKED ? 1 : 2);
        if (c == 'q')
            done_stopprint++;
    }

    if (!done_stopprint) {
        c = ask ? yn_function("Do you want to see a breakdown of your score?",
                              ynqchars, defquery) : defquery;
        if (c == 'y')
            calc_score(how, TRUE, umoney);
        if (c == 'q')
            done_stopprint++;
    }
}

/* like disclose, but don't ask any questions */
static void
dump_disclose(int how)
{
    struct obj *obj;

    /* temporarily redirect menu window output into the dumpfile */
    dump_catch_menus(TRUE);

    /* re-"display" all the disclosure menus */
    /* make sure the inventory is fully identified, even if DYWYPI = n */
    for (obj = invent; obj; obj = obj->nobj) {
        discover_object(obj->otyp, TRUE, FALSE, TRUE);
        obj->known = obj->bknown = obj->dknown = obj->rknown = 1;
    }
    display_inventory(NULL, TRUE);
    container_contents(invent, TRUE, TRUE);
    dump_spells();
    dump_skills();
    enlightenment(how >= PANICKED ? 1 : 2);     /* final */
    list_vanquished('y', FALSE);
    list_genocided('y', FALSE);
    show_conduct(how >= PANICKED ? 1 : 2);
    dooverview();
    dohistory();
    calc_score(how, TRUE, money_cnt(invent) + hidden_gold());

    /* make menus work normally again */
    dump_catch_menus(FALSE);
}


/* try to get the player back in a viable state after being killed */
static void
savelife(int how)
{
    u.uswldtim = 0;
    u.uhp = u.uhpmax;
    if (u.uhunger < 500) {
        u.uhunger = 500;
        newuhs(FALSE);
    }
    /* cure impending doom of sickness hero won't have time to fix */
    if ((Sick & TIMEOUT) == 1) {
        u.usick_type = 0;
        Sick = 0;
    }
    if (how == CHOKING)
        init_uhunger();
    nomovemsg = "You survived that attempt on your life.";
    flags.move = 0;
    if (multi > 0)
        multi = 0;
    else
        multi = -1;
    if (u.utrap && u.utraptype == TT_LAVA)
        u.utrap = 0;
    iflags.botl = 1;
    u.ugrave_arise = NON_PM;
    HUnchanging = 0L;
    flush_screen();
}

/*
 * Get valuables from the given list.  Revised code: the list always remains
 * intact.
 */
static void
get_valuables(struct obj *list)
{
    struct obj *obj;
    int i;

    /* find amulets and gems, ignoring all artifacts */
    for (obj = list; obj; obj = obj->nobj)
        if (Has_contents(obj)) {
            get_valuables(obj->cobj);
        } else if (obj->oartifact) {
            continue;
        } else if (obj->oclass == AMULET_CLASS) {
            i = obj->otyp - FIRST_AMULET;
            if (!amulets[i].count) {
                amulets[i].count = obj->quan;
                amulets[i].typ = obj->otyp;
            } else
                amulets[i].count += obj->quan;  /* always adds one */
        } else if (obj->oclass == GEM_CLASS && obj->otyp < LUCKSTONE) {
            i = min(obj->otyp, LAST_GEM + 1) - FIRST_GEM;
            if (!gems[i].count) {
                gems[i].count = obj->quan;
                gems[i].typ = obj->otyp;
            } else
                gems[i].count += obj->quan;
        }
    return;
}

/*
 *  Sort collected valuables, most frequent to least.  We could just
 *  as easily use qsort, but we don't care about efficiency here.
 */
static void
sort_valuables(struct valuable_data list[],
               int size    /* max value is less than 20 */ )
{
    int i, j;
    struct valuable_data ltmp;

    /* move greater quantities to the front of the list */
    for (i = 1; i < size; i++) {
        if (list[i].count == 0)
            continue;   /* empty slot */
        ltmp = list[i]; /* structure copy */
        for (j = i; j > 0; --j)
            if (list[j - 1].count >= ltmp.count)
                break;
            else {
                list[j] = list[j - 1];
            }
        list[j] = ltmp;
    }
    return;
}

/* called twice; first to calculate total, then to list relevant items */
static int artifact_score(struct obj *list,
                          boolean counting,  /* true => add up points;
                                                false => display them */
                          struct menulist *menu) {
    char pbuf[BUFSZ];
    struct obj *otmp;
    long value, total;
    short dummy;        /* object type returned by artifact_name() */

    total = 0;

    for (otmp = list; otmp; otmp = otmp->nobj) {
        if (otmp->oartifact || otmp->otyp == BELL_OF_OPENING ||
            otmp->otyp == SPE_BOOK_OF_THE_DEAD ||
            otmp->otyp == CANDELABRUM_OF_INVOCATION) {
            value = arti_cost(otmp);    /* zorkmid value */
            if (counting) {
                total += value;
            } else {
                makeknown(otmp->otyp);
                otmp->known = otmp->dknown = otmp->bknown = otmp->rknown = 1;
                /* assumes artifacts don't have quan > 1 */
                sprintf(pbuf, "%s%s (worth %ld %s)",
                        the_unique_obj(otmp) ? "The " : "",
                        otmp->oartifact ?
                        artifact_name(xname(otmp), &dummy) :
                        OBJ_NAME(objects[otmp->otyp]), value, currency(value));
                add_menutext(menu, pbuf);
            }
        }
        if (Has_contents(otmp))
            artifact_score(otmp->cobj, counting, menu);
    }
    return total;
}

/* Calculate the player's score, and return it (show = FALSE), or
   show it to the user (show = TRUE). */
long
calc_score(int how, boolean show, long umoney)
{
    /* The principle here is that each category is worth up to 30000 points;
       most categories are calculated via base-2 logarithm, to give massive
       diminishing returns to farming in any particular category; categories
       which have an intrinsic maximum anyway (such as the percentages) instead 
       are based on the square root of the percentage progress made. */
    long total = 0;
    long category_raw;
    double category_ratio;
    long category_points;
    double elog2;
    struct menulist menu;
    char buf[BUFSZ];

    elog2 = log(2) / 1000.0;
    /* Initialise the explanation window, if show is true. */
    if (show) {
        init_menulist(&menu);
    }
    /* Gold. x gold scores log2(x+1)*1000 points (maxing at 30000 for MAXINT
       gold; just in case gold can be 64-bit, we cap it at the 32-bit MAXINT
       first). This counts profit from starting inventory, rather than the
       amount, to avoid giving bonuses to early-game Healers. */
    category_raw = umoney;
    category_raw -= u.umoney0;
    if (category_raw < 0)
        category_raw = 0;
    category_points = log(category_raw + 1) / elog2 + 0.5;
    if (category_points > 30000)
        category_points = 30000;
    total += category_points;
    if (show) {
        sprintf(buf, "Gold:            %10ld                    (%5ld points)",
                category_raw, category_points);
        add_menutext(&menu, buf);
    }
    /* Experience. Although this maxes at 30, the ratio isn't displayed. */
    category_raw = u.ulevel;
    category_points = sqrt((u.ulevel - 1.0) / 29.0) * 30000.0 + 0.5;
    total += category_points;
    if (show) {
        sprintf(buf, "Experience:      %10ld level%s             (%5ld points)",
                category_raw, category_raw == 1 ? " " : "s", category_points);
        add_menutext(&menu, buf);
    }
    /* Exploration. This is based on the ratio of the Sanctum depth to the
       deepest level reached, and is based on the square root of the ratio. */
    category_raw = deepest_lev_reached(FALSE);
    category_ratio = category_raw * 100.0 / depth(&sanctum_level);
    category_points =
        sqrt((category_raw - 1) / (double)(depth(&sanctum_level) -
                                           1)) * 30000.0 + 0.5;
    total += category_points;
    if (show) {
        sprintf(buf, "Exploration:     %10ld level%s   (%6.2f%%) (%5ld points)",
                category_raw, category_raw == 1 ? " " : "s", category_ratio,
                category_points);
        add_menutext(&menu, buf);
    }
    /* Discoveries. Based on the ratio of the number of items discovered, to
       the maximum possible number of items discovered. */
    {
        int curd, maxd;

        count_discovered_objects(&curd, &maxd);
        category_raw = curd;
        category_ratio = curd * 100.0 / maxd;
        category_points = sqrt(category_ratio) * 3000.0 + 0.5;
    }
    total += category_points;
    if (show) {
        sprintf(buf, "Discoveries:     %10ld item%s    (%6.2f%%) (%5ld points)",
                category_raw, category_raw == 1 ? " " : "s", category_ratio,
                category_points);
        add_menutext(&menu, buf);
    }
    /* Valuables. Scored the same way as gold, based on their gp values. Scores 
       only on ascension or escape. */
    category_raw = 0;
    if (how == ESCAPED || how == ASCENDED) {
        const struct val_list *val;
        int i;

        for (val = valuables; val->list; val++)
            for (i = 0; i < val->size; i++) {
                val->list[i].count = 0L;
            }
        get_valuables(invent);
        for (val = valuables; val->list; val++)
            for (i = 0; i < val->size; i++)
                if (val->list[i].count != 0L)
                    category_raw +=
                        val->list[i].count *
                        (long)objects[val->list[i].typ].oc_cost;
        category_points = log(category_raw + 1) / elog2 + 0.5;
        total += category_points;
        if (show) {
            sprintf(buf,
                    "Valuables value: %10ld                    (%5ld points)",
                    category_raw, category_points);
            add_menutext(&menu, buf);
        }
    } else if (show) {
        add_menutext(&menu,
                     "Valuables value: (no points given unless you survive)");
    }
    /* Artifacts. */
    category_raw = artifact_score(invent, TRUE, 0);
    category_points = log(category_raw + 1) / elog2 + 0.5;
    total += category_points;
    if (show) {
        sprintf(buf, "Artifact value:  %10ld                    (%5ld points)",
                category_raw, category_points);
        add_menutext(&menu, buf);
    }
    /* Variety of monsters vanquished. (All that matters is whether or not a
       monster was killed, so people can't farm this score up indefinitely; and
       this counts vanquished not killed so that pacifists aren't penalised for
       their conduct.) */
    {
        int i;

        category_raw = 0;
        for (i = LOW_PM; i < NUMMONS; i++) {
            if (mvitals[i].died)
                category_raw++;
        }
    }
    category_ratio = category_raw * 100.0 / (NUMMONS - LOW_PM);
    category_points = sqrt(category_ratio) * 3000.0 + 0.5;
    total += category_points;
    if (show) {
        sprintf(buf, "Variety of kills:%10ld monster%s (%6.2f%%) (%5ld points)",
                category_raw, category_raw == 1 ? " " : "s", category_ratio,
                category_points);
        add_menutext(&menu, buf);
    }
    /* Time penalty. */
    category_raw = moves;
    category_points = log(max(moves, 2000) / 2000.0) / elog2;
    total -= category_points;
    if (show) {
        sprintf(buf, "Time penalty:    %10ld turn%s              (%5ld points)",
                category_raw, category_raw == 1 ? " " : "s", -category_points);
        add_menutext(&menu, buf);
    }
    /* Survival. A multiplier. */
    if (how == ASCENDED)
        category_raw = 200;
    else if (how == ESCAPED)
        category_raw = 100;
    else if (how == QUIT)
        category_raw = 90;
    else
        category_raw = 80;
    total *= category_raw;
    total /= 100;
    if (show) {
        sprintf(buf, "Survival:        %10s  (score multiplied by %3ld%%)",
                category_raw == 80 ? (how ==
                                      -1 ? "unknown" : "died") : category_raw ==
                90 ? "quit" : category_raw == 200 ? "ascended" : "survived",
                category_raw);
        add_menutext(&menu, buf);
        add_menutext(&menu, "");
        sprintf(buf, "Total score:                               %10ld", total);
        add_menutext(&menu, buf);
    }
    /* Finishing off. */
    if (show) {
        display_menu(menu.items, menu.icount, "Score breakdown:", PICK_NONE,
                     PLHINT_ANYWHERE, NULL);
        free(menu.items);
    }
    return total;
}

static boolean
check_survival(int how, char *kilbuf)
{
    if (how == TRICKED) {
        if (killer) {
            paniclog("trickery", killer);
            killer = 0;
        }
        if (wizard) {
            pline("You are a very tricky wizard, it seems.");
            return TRUE;
        }
    }

    /* kilbuf: used to copy killer in case it comes from something like
       xname(), which would otherwise get overwritten when we call xname() when 
       listing possessions pbuf: holds sprintf'd output for raw_print and
       putstr */
    if (how == ASCENDED || (!killer && how == GENOCIDED))
        killer_format = NO_KILLER_PREFIX;
    /* Avoid killed by "a" burning or "a" starvation */
    if (!killer && (how == STARVING || how == BURNING))
        killer_format = KILLED_BY;
    strcpy(kilbuf, (!killer || how >= PANICKED ? deaths[how] : killer));
    killer = kilbuf;

    if (how < PANICKED)
        u.umortality++;
    if (Lifesaved && (how <= GENOCIDED)) {
        pline("But wait...");
        makeknown(AMULET_OF_LIFE_SAVING);
        pline("Your medallion %s!", !Blind ? "begins to glow" : "feels warm");
        if (how == CHOKING)
            pline("You vomit ...");
        pline("You feel much better!");
        pline("The medallion crumbles to dust!");
        if (uamul)
            useup(uamul);

        adjattrib(A_CON, -1, TRUE);
        if (u.uhpmax <= 0)
            u.uhpmax = 10;      /* arbitrary */
        savelife(how);
        if (how == GENOCIDED)
            pline("Unfortunately you are still genocided...");
        else {
            killer = 0;
            killer_format = 0;
            historic_event(FALSE,
                           "were saved from death by your amulet of life saving!");
            return TRUE;
        }
    }
    if ((wizard || discover) && (how <= GENOCIDED)) {
        if (yn("Die?") == 'y')
            return FALSE;
        pline("OK, so you don't %s.", (how == CHOKING) ? "choke" : "die");
        if (u.uhpmax <= 0)
            u.uhpmax = u.ulevel * 8;    /* arbitrary */
        savelife(how);
        killer = 0;
        killer_format = 0;
        historic_event(FALSE, "were saved from death by your wizard powers!");
        return TRUE;
    }

    return FALSE;
}

void
display_rip(int how, char *kilbuf, char *pbuf, long umoney)
{
    char outrip_buf[BUFSZ];
    boolean show_endwin = FALSE;
    struct menulist menu;

    init_menulist(&menu);

    /* clean up unneeded windows */
    if (program_state.game_running) {
        win_pause_output(P_MESSAGE);

        if (!done_stopprint || flags.tombstone)
            show_endwin = TRUE;

        if (how < GENOCIDED && flags.tombstone && show_endwin) {
            /* Put together death description */
            switch (killer_format) {
            default:
                impossible("bad killer format?");
            case KILLED_BY_AN:
                strcpy(outrip_buf, killed_by_prefix[how]);
                strcat(outrip_buf, an(killer));
                break;
            case KILLED_BY:
                strcpy(outrip_buf, killed_by_prefix[how]);
                strcat(outrip_buf, killer);
                break;
            case NO_KILLER_PREFIX:
                strcpy(outrip_buf, killer);
                break;
            }
        }
    } else
        done_stopprint = 1;

/* changing kilbuf really changes killer. we do it this way because
   killer is declared a (const char *)
*/
    if (u.uhave.amulet)
        strcat(kilbuf, " (with the Amulet)");
    else if (how == ESCAPED) {
        if (Is_astralevel(&u.uz))       /* offered Amulet to wrong deity */
            strcat(kilbuf, " (in celestial disgrace)");
        else if (carrying(FAKE_AMULET_OF_YENDOR))
            strcat(kilbuf, " (with a fake Amulet)");
        /* don't bother counting to see whether it should be plural */
    }

    if (!done_stopprint) {
        sprintf(pbuf, "%s %s the %s...", Goodbye(), plname,
                how !=
                ASCENDED ? (const char *)((flags.female && urole.name.f) ?
                                          urole.name.f : urole.name.m) :
                (const char *)(flags.female ?
                               "Demigoddess" : "Demigod"));
        add_menutext(&menu, pbuf);
        add_menutext(&menu, "");
    }

    if (how == ESCAPED || how == ASCENDED) {
        struct monst *mtmp;
        struct obj *otmp;
        const struct val_list *val;
        int i;

        keepdogs(TRUE);
        viz_array[0][0] |= IN_SIGHT;    /* need visibility for naming */
        mtmp = mydogs;
        if (!done_stopprint)
            strcpy(pbuf, "You");
        if (mtmp) {
            while (mtmp) {
                if (!done_stopprint)
                    sprintf(eos(pbuf), " and %s", mon_nam(mtmp));
                mtmp = mtmp->nmon;
            }
            if (!done_stopprint)
                add_menutext(&menu, pbuf);
            pbuf[0] = '\0';
        } else {
            if (!done_stopprint)
                strcat(pbuf, " ");
        }
        if (!done_stopprint) {
            sprintf(eos(pbuf), "%s with %d point%s,",
                    how ==
                    ASCENDED ? "went to your reward" :
                    "escaped from the dungeon", u.urexp, plur(u.urexp));
            add_menutext(&menu, pbuf);
        }

        if (!done_stopprint)
            artifact_score(invent, FALSE, &menu);       /* list artifacts */

        /* list valuables here */
        for (val = valuables; val->list; val++) {
            sort_valuables(val->list, val->size);
            for (i = 0; i < val->size && !done_stopprint; i++) {
                int typ = val->list[i].typ;
                long count = val->list[i].count;

                if (count == 0L)
                    continue;
                if (objects[typ].oc_class != GEM_CLASS || typ <= LAST_GEM) {
                    otmp = mksobj(level, typ, FALSE, FALSE);
                    makeknown(otmp->otyp);
                    otmp->known = 1;    /* for fake amulets */
                    otmp->dknown = 1;   /* seen it (blindness fix) */
                    otmp->onamelth = 0;
                    otmp->quan = count;
                    sprintf(pbuf, "%8ld %s (worth %ld %s),", count, xname(otmp),
                            count * (long)objects[typ].oc_cost, currency(2L));
                    obfree(otmp, NULL);
                } else {
                    sprintf(pbuf, "%8ld worthless piece%s of colored glass,",
                            count, plur(count));
                }
                add_menutext(&menu, pbuf);
            }
        }

    } else if (!done_stopprint) {
        /* did not escape or ascend */
        if (u.uz.dnum == 0 && u.uz.dlevel <= 0) {
            /* level teleported out of the dungeon; `how' is DIED, due to
               falling or to "arriving at heaven prematurely" */
            sprintf(pbuf, "You %s beyond the confines of the dungeon",
                    (u.uz.dlevel < 0) ? "passed away" : ends[how]);
        } else {
            /* more conventional demise */
            const char *where = dungeons[u.uz.dnum].dname;

            if (Is_astralevel(&u.uz))
                where = "The Astral Plane";
            sprintf(pbuf, "You %s in %s", ends[how], where);
            if (!In_endgame(&u.uz) && !Is_knox(&u.uz))
                sprintf(eos(pbuf), " on dungeon level %d",
                        In_quest(&u.uz) ? dunlev(&u.uz) : depth(&u.uz));
        }

        sprintf(eos(pbuf), " with %d point%s,", u.urexp, plur(u.urexp));
        add_menutext(&menu, pbuf);
    }

    if (!done_stopprint) {
        sprintf(pbuf, "and %ld piece%s of gold, after %u move%s.", umoney,
                plur(umoney), moves, plur(moves));
        add_menutext(&menu, pbuf);
    }
    if (!done_stopprint) {
        sprintf(pbuf,
                "You were level %d with a maximum of %d hit point%s when you %s.",
                u.ulevel, u.uhpmax, plur(u.uhpmax), ends[how]);
        add_menutext(&menu, pbuf);
        add_menutext(&menu, "");
    }
    if (!done_stopprint)
        outrip(menu.items, menu.icount, how <= GENOCIDED, plname, umoney,
               outrip_buf, how, getyear());

    free(menu.items);
}

/* Be careful not to call panic from here! */
void
done(int how)
{

    if (check_survival(how, killbuf))
        return;

    done_noreturn(how);
}

/* Be careful not to call panic from here! */
static void NORETURN
done_noreturn(int how)
{
    int fd;
    boolean taken;
    char pbuf[BUFSZ];
    boolean bones_ok;
    struct obj *corpse = NULL;
    long umoney;

    /* replays are done here: no dumping or high-score calculation required */
    if (program_state.viewing)
        terminate();

    /* 
     *      The game is now over...
     */
    program_state.gameover = 1;

    /* don't do the whole post-game dance if the game exploded */
    if (how == PANICKED)
        terminate();

    log_command_result();
    /* render vision subsystem inoperative */
    iflags.vision_inited = 0;
    /* might have been killed while using a disposable item, so make sure it's
       gone prior to inventory disclosure and creation of bones data */
    inven_inuse(TRUE);

    /* Sometimes you die on the first move.  Life's not fair. On those rare
       occasions you get hosed immediately, go out smiling... :-) -3. */
    if (moves <= 1 && how < PANICKED)   /* You die... --More-- */
        pline("Do not pass go.  Do not collect 200 %s.", currency(200L));

    bones_ok = (how < GENOCIDED) && can_make_bones(&u.uz);

    if (how == TURNED_SLIME)
        u.ugrave_arise = PM_GREEN_SLIME;

    if (bones_ok && u.ugrave_arise < LOW_PM) {
        /* corpse gets burnt up too */
        if (how == BURNING)
            u.ugrave_arise = (NON_PM - 2);      /* leave no corpse */
        else if (how == STONING)
            u.ugrave_arise = (NON_PM - 1);      /* statue instead of corpse */
        else if (u.ugrave_arise == NON_PM &&
                 !(mvitals[u.umonnum].mvflags & G_NOCORPSE)) {
            int mnum = u.umonnum;

            if (!Upolyd) {
                /* Base corpse on race when not poly'd since original u.umonnum 
                   is based on role, and all role monsters are human. */
                mnum = (flags.female &&
                        urace.femalenum !=
                        NON_PM) ? urace.femalenum : urace.malenum;
            }
            corpse = mk_named_object(CORPSE, &mons[mnum], u.ux, u.uy, plname);
            sprintf(pbuf, "%s, %s%s", plname,
                    killer_format ==
                    NO_KILLER_PREFIX ? "" : killed_by_prefix[how],
                    killer_format == KILLED_BY_AN ? an(killer) : killer);
            make_grave(level, u.ux, u.uy, pbuf);
        }
    }

    if (how == QUIT) {
        killer_format = NO_KILLER_PREFIX;
        if (u.uhp < 1) {
            how = DIED;
            u.umortality++;     /* skipped above when how==QUIT */
            /* note that killer is pointing at killbuf */
            strcpy(killbuf, "quit while already on Charon's boat");
        }
    }
    if (how == ESCAPED)
        killer_format = NO_KILLER_PREFIX;

    fd = logfile;
    log_finish(LS_DONE);
    /* write_log_toptenentry needs killer_format */
    write_log_toptenentry(fd, how);
    /* in case of a subsequent panic(), there's no point trying to save */
    program_state.something_worth_saving = 0;

    /* these affect score and/or bones, but avoid them during panic */
    taken = paybill((how == ESCAPED) ? -1 : (how != QUIT));
    paygd();
    clearpriests();

    win_pause_output(P_MESSAGE);

    if (flags.end_disclose != DISCLOSE_NO_WITHOUT_PROMPT)
        disclose(how, taken, money_cnt(invent) + hidden_gold());

    /* calculate score, before creating bones [container gold] */
    umoney = money_cnt(invent) + hidden_gold();
    u.urexp = calc_score(how, FALSE, umoney);

    begin_dump(how);
    dump_disclose(how);

    /* finish_paybill should be called after disclosure but before bones */
    if (bones_ok && taken)
        finish_paybill();

    if (bones_ok && !discover) {
        if (!wizard || yn("Save bones?") == 'y')
            savebones(corpse);
        /* corpse may be invalid pointer now so ensure that it isn't used again 
         */
        corpse = NULL;
    }

    /* update gold for the rip output, which can't use hidden_gold()
       (containers will be gone by then if bones just got saved...) */
    done_money = umoney;

    end_dump(how, killbuf, pbuf, umoney);
    display_rip(how, killbuf, pbuf, umoney);

    /* generate a topten entry for this game. update_topten does not display
       anything. */
    update_topten(how);

    terminate();
}


static void
container_contents(struct obj *list, boolean identified, boolean all_containers)
{
    struct obj *box, *obj;
    char buf[BUFSZ];
    int i, nr_items = 10, icount = 0;
    struct nh_objitem *items = malloc(nr_items * sizeof (struct nh_objitem));
    struct obj **objlist;

    for (box = list; box; box = box->nobj) {
        if (Is_container(box) || box->otyp == STATUE) {
            if (box->otyp == BAG_OF_TRICKS) {
                continue;       /* wrong type of container */
            } else if (box->cobj) {
                /* count contained objects */
                icount = 0;
                for (obj = box->cobj; obj; obj = obj->nobj)
                    icount++;
                objlist = malloc(icount * sizeof (struct obj *));

                /* add the objects to a list */
                icount = 0;
                for (obj = box->cobj; obj; obj = obj->nobj) {
                    if (identified) {
                        makeknown(obj->otyp);
                        obj->known = obj->bknown = obj->dknown = obj->rknown =
                            1;
                    }
                    objlist[icount++] = obj;
                }

                /* sort the list */
                qsort(objlist, icount, sizeof (struct obj *), obj_compare);

                /* add the sorted objects to the menu */
                for (i = 0; i < icount; i++)
                    add_objitem(&items, &nr_items, MI_NORMAL, i, i + 1,
                                doname(objlist[i]), objlist[i], FALSE);

                free(objlist);
                sprintf(buf, "Contents of %s:", the(xname(box)));
                display_objects(items, icount, buf, PICK_NONE, PLHINT_CONTAINER,
                                NULL);
                if (all_containers)
                    container_contents(box->cobj, identified, TRUE);
            } else {
                pline("%s empty.", Tobjnam(box, "are"));
                win_pause_output(P_MESSAGE);
            }
        }
        if (!all_containers)
            break;
    }

    free(items);
}


void
terminate(void)
{
    /* don't bother to try to release memory if we're in panic mode, to avoid
       trouble in case that happens to be due to memory problems */
    if (!program_state.panicking && !program_state.viewing) {
        freedynamicdata();
        dlb_cleanup();
    }

    program_state.game_running = 0;
    if (!program_state.panicking)       /* logging could be in disorder, ex: RO 
                                           logfile */
        log_finish(LS_IN_PROGRESS);     /* didn't necessarily get here via
                                           done() */

    /* try to leave gracefully - this should return control to the ui code */
    if (exit_jmp_buf_valid) {
        exit_jmp_buf_valid = 0;
        nh_longjmp(exit_jmp_buf, 1);
    }

    /* no jmp_buf. This can only happen when an unguarded api function calls
       panic() This should not happen. */
    exit(1);
}

void
list_vanquished(char defquery, boolean ask)
{
    int i, lev;
    int ntypes = 0, max_lev = 0, nkilled;
    long total_killed = 0L;
    char c;
    char buf[BUFSZ];
    struct menulist menu;

    /* get totals first */
    for (i = LOW_PM; i < NUMMONS; i++) {
        if (mvitals[i].died)
            ntypes++;
        total_killed += (long)mvitals[i].died;
        if (mons[i].mlevel > max_lev)
            max_lev = mons[i].mlevel;
    }

    /* vanquished creatures list; includes all dead monsters, not just those
       killed by the player */
    if (ntypes != 0) {
        c = ask ? yn_function("Do you want an account of creatures vanquished?",
                              ynqchars, defquery) : defquery;
        if (c == 'q')
            done_stopprint++;
        if (c == 'y') {
            init_menulist(&menu);

            /* countdown by monster "toughness" */
            for (lev = max_lev; lev >= 0; lev--)
                for (i = LOW_PM; i < NUMMONS; i++)
                    if (mons[i].mlevel == lev &&
                        (nkilled = mvitals[i].died) > 0) {
                        if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST) {
                            sprintf(buf, "%s%s",
                                    !type_is_pname(&mons[i]) ? "The " : "",
                                    mons[i].mname);
                            if (nkilled > 1) {
                                switch (nkilled) {
                                case 2:
                                    sprintf(eos(buf), " (twice)");
                                    break;
                                case 3:
                                    sprintf(eos(buf), " (thrice)");
                                    break;
                                default:
                                    sprintf(eos(buf), " (%d time%s)", nkilled,
                                            plur(nkilled));
                                    break;
                                }
                            }
                        } else {
                            /* trolls or undead might have come back, but we
                               don't keep track of that */
                            if (nkilled == 1)
                                strcpy(buf, an(mons[i].mname));
                            else
                                sprintf(buf, "%d %s", nkilled,
                                        makeplural(mons[i].mname));
                        }
                        add_menutext(&menu, buf);
                    }
            if (Hallucination)
                add_menutext(&menu, "and a partridge in a pear tree");
            if (ntypes > 1) {
                add_menutext(&menu, "");
                sprintf(buf, "%ld creatures vanquished.", total_killed);
                add_menutext(&menu, buf);
            }
            display_menu(menu.items, menu.icount, "Vanquished creatures:",
                         PICK_NONE, PLHINT_ANYWHERE, NULL);
            free(menu.items);
        }
    }
}

/* number of monster species which have been genocided */
int
num_genocides(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if (mvitals[i].mvflags & G_GENOD)
            ++n;

    return n;
}

/* number of monster species which have been extincted */
int
num_extinctions(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if ((mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ))
            ++n;

    return n;
}

/* number of monster species which have been vanquished */
int
num_vanquished(void)
{
    int i, n = 0;

    for (i = LOW_PM; i < NUMMONS; ++i)
        if (mvitals[i].died)
            ++n;

    return n;
}

void
list_genocided(char defquery, boolean ask)
{
    int i;
    int ngenocided, nextincted;
    char c, *query, *title;
    char buf[BUFSZ];
    struct menulist menu;

    ngenocided = nextincted = 0;
    for (i = LOW_PM; i < NUMMONS; ++i) {
        if (mvitals[i].mvflags & G_GENOD)
            ngenocided++;
        if ((mvitals[i].mvflags & G_GONE) && !(mons[i].geno & G_UNIQ))
            nextincted++;
    }

    /* genocided species list */
    if (ngenocided != 0 || nextincted != 0) {
        query =
            nextincted ? "Do you want a list of species genocided or extinct?" :
            "Do you want a list of species genocided?";
        c = ask ? yn_function(query, ynqchars, defquery) : defquery;
        if (c == 'q')
            done_stopprint++;
        if (c == 'y') {
            init_menulist(&menu);
            for (i = LOW_PM; i < NUMMONS; i++)
                if ((mvitals[i].mvflags & G_GENOD) ||
                    ((mvitals[i].mvflags & G_EXTINCT) &&
                     !(mons[i].geno & G_UNIQ))) {
                    if ((mons[i].geno & G_UNIQ) && i != PM_HIGH_PRIEST)
                        sprintf(buf, "%s%s",
                                !type_is_pname(&mons[i]) ? "" : "the ",
                                mons[i].mname);
                    else
                        strcpy(buf, makeplural(mons[i].mname));

                    if (!(mvitals[i].mvflags & G_GENOD))
                        strcat(buf, " (extinct)");
                    add_menutext(&menu, buf);
                }

            add_menutext(&menu, "");
            sprintf(buf, "%d species genocided.", ngenocided);
            if (ngenocided)
                add_menutext(&menu, buf);
            sprintf(buf, "%d species extinct.", nextincted);
            if (nextincted)
                add_menutext(&menu, buf);

            title =
                nextincted ? "Genocided or extinct species:" :
                "Genocided species:";
            display_menu(menu.items, menu.icount, title, PICK_NONE,
                         PLHINT_ANYWHERE, NULL);
            free(menu.items);
        }
    }
}

/*end.c*/
